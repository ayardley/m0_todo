Before M0 is considered "final", the following need to happen:

TODO:
 * nail down calling conventions recommendations
   - this means that we have working example code for whatever we're recommending
   - putting the calling conventions burden on the callee is preferable
   - become knowledgeable enough to make sure that the calling conventions don't make useful optimizations impossible
     - polymorphic inline caching, prototypes with multiple dispatch, JIT, others
 * get some kind of ffi implementation working *and tested* in the Perl interp, if possible
   - candidate Perl modules:
   - FFI - probably abandoned, can "fix" test failures, doesn't seem to be commonly used
   - C::Dynalib - tests fail gloriously, probably abandoned, doesn't seem to be commonly used
   - perl-ctypes - test fail gloriously in an infinite loop, doesn't look very usable
   - syscall and pack - ???
 * carefully define the conversion semantics for itoa/afromi
 * figure out exception recommendations
 * figure out what it means to support mmapping
   - this means that you don't need to mutate from the file at runtime
   - this is essentially a characteristic that we need to revisit regularly as the spec solidifies
 * decide if there'll be support for non-uniform-sized call frames
   - this drops some optimizations, but it's very likely a Good Idea
   - make sure it's not impossible for an implementation to support this while still complying with the spec
 * be certain that M0 can provide solid lvalue semantics
   - http://trac.parrot.org/parrot/wiki/WhyDoesNQPGenerateInefficientCode
 * complete coverage of the interp and assembler according to Devel::Cover
   - an occasional weird error condition can be uncovered, but everything that reasonably can be covered should be
   - this also means we're confident that any implementation that passes all tests is complete
 * figure out how much fanciness can be done with registers
   - iwbn to have them be space-efficient
   - iwbn to enable mapping of N registers to machine-specific registers
   - iwbn to somehow map M0 registers to hardware registers in general
   - iwbn to enable precise GC, i.e. no stack walking

IN PROGRESS:
 * write a glossy brochure about M0
   - integrate feedback from kid51
 * blog about the long-term plan for M0 integration into Parrot


COMPLETED:
 * decide on itoa or afromi
 * figure out endianness and word size for m0b
 * find a better name for deref and/or set_ref (existing names wfm)
 * decide whether goto_chunk should be just goto or if it should also update CHUNK, BCS, etc (the latter)
 * decide whether the M0 interp should install a default exception handler to puke to stderr
